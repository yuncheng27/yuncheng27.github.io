<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://localhost:4000/warn.html">
<![endif]-->
<meta charset="utf-8">
<meta http-equiv="X-DNS-Prefetch-Control" content="on">
<link rel="dns-prefetch" href="http://localhost:4000">
<link rel="dns-prefetch" href="//www.google-analytics.com">
<link rel="prefetch" href="http://localhost:4000">
<link rel="prefetch" href="//www.google-analytics.com">


<link rel="prerender" href="http://localhost:4000">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://localhost:4000">
<meta name="author" content="方雷">

<link rel="stylesheet" href="/css/JSimple.css">


<link rel="shortcut icon" href="/images/favicon.png">


<title>【项目】搜索引擎 - Fronna</title>

<meta name="keywords" content="">

<meta name="description " content="一个流浪歌者的遥远故乡">


    

    

<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="F">F</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">Fronna</h1>
        <h3 class="cover-siteTitle">致广大而尽精微</h3>
        <p class="cover-siteDesc">一个流浪歌者的遥远故乡</p>
        <div class="cover-sns">
            
    &nbsp;&nbsp;<div class="btn btn-github">
        <a href="https://github.com/yuncheng27" target="_blank" title="github" ref="friend">
            <i class="fa fa-github"></i>
        </a>
    </div>

    &nbsp;&nbsp;<div class="btn btn-telegram">
        <a href="http://t.me/yuncheng27" target="_blank" title="telegram" ref="friend">
            <i class="fa fa-telegram"></i>
        </a>
    </div>

    &nbsp;&nbsp;<div class="btn btn-quora">
        <a href="https://www.quora.com/profile/fronna" target="_blank" title="quora" ref="friend">
            <i class="fa fa-quora"></i>
        </a>
    </div>

    &nbsp;&nbsp;<div class="btn btn-twitter">
        <a href="https://twitter.com/yuncheng27" target="_blank" title="twitter" ref="friend">
            <i class="fa fa-twitter"></i>
        </a>
    </div>


        </div>
    </div>
</div>

            <div class="page-title">
    <ul>
        <li><a href="/">最近</a></li>
        
            
                <li class="active">
                    <a href="/categories/Tech" data-name="技术">技术</a>
                </li>
            
                <li class="">
                    <a href="/categories/Math" data-name="数学">数学</a>
                </li>
            
                <li class="">
                    <a href="/categories/Finance" data-name="金融">金融</a>
                </li>
            
                <li class="">
                    <a href="/categories/SpaceIndustry" data-name="空工">空工</a>
                </li>
            
                <li class="">
                    <a href="/categories/NaturalScience" data-name="自科">自科</a>
                </li>
            
                <li class="">
                    <a href="/categories/Fitness" data-name="健康">健康</a>
                </li>
            
                <li class="">
                    <a href="/categories/Classical" data-name="音乐">音乐</a>
                </li>
            
                <li class="">
                    <a href="/categories/Think" data-name="哲思">哲思</a>
                </li>
            
                <li class="">
                    <a href="/categories/Others" data-name="其他">其他</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <input type="text"
               readonly="readonly"
               id="local-search-input-tip"
               placeholder="按s搜索，alt取消" />
        <button type="button" disabled="disabled" class="search-form-submit"><i class="fa fa-search"></i></button>
    </form>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="http://blog.fronna.com"
                   target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="http://blog.fronna.com/about.html"
                       target="_blank">方雷</a>
                    <span title="最后编辑于&nbsp;2019-08-13">2019-08-13</span>
                </p>
                <p>Don&#39;t cry, Alfred! I need all my courage to die at twenty.</p>
            </div>
            <h2 class="post-title">【项目】搜索引擎</h2>
            <div class="post-meta">
                本文共计7989个字 |
                您是第&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <blockquote>
<p>做完一个项目，写技术文档，可以整理自己的思路，对这个项目中的知识点，要知其然，更要知其所以然。</p>
</blockquote>
<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>一个超文本搜索引擎项目，使用C++编写</p>
<h2 id="设计框架及实现细节"><a href="#设计框架及实现细节" class="headerlink" title="设计框架及实现细节"></a>设计框架及实现细节</h2><p>该项目分为以下几个模块：</p>
<ul>
<li>data(存放输入的搜索材料和输出的解析文本)</li>
<li>parser(数据解析)</li>
<li>searcher(搜索引擎)</li>
<li>HttpServer(Http服务器和前端页面)</li>
<li>common(各个模块共用的类)</li>
</ul>
<h3 id="data模块"><a href="#data模块" class="headerlink" title="data模块"></a>data模块</h3><ul>
<li>input/html/：放置需要搜索的html文档</li>
<li>tmp/：放置解析完输出的文本raw_input</li>
</ul>
<h3 id="parser模块"><a href="#parser模块" class="headerlink" title="parser模块"></a>parser模块</h3><p>数据处理模块执行的步骤是：先枚举文件<code>EnumFile(g_input_path, &amp;file_list)</code>把路径保存到file_list的vector数组里，其中<code>const std::string g_input_path = &quot;../data/input&quot;</code>；然后依次处理每个枚举出的路径(auto循环)，并对每个文件进行分析<code>ParseFile(file_path, &amp;info)</code>，把分析结果按照一行的形式写入到输出文件中<code>WriteOutput(info, output_file)</code>，其中output_file是<code>std::ofstream output_file(g_output_path.c_str())</code>，而<code>const std::string g_output_path = &quot;../data/tmp/raw_input&quot;</code><br><strong>1.数据处理模块(parser.cc)</strong></p>
<ul>
<li>去标签<ul>
<li>目录遍历和枚举<br>a.使用boost第三方库<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem/path.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem/operations.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
b.枚举文件<code>bool EnumFile()</code><br>boost递归遍历目录，需要用到<code>boost::filesystem</code>命名空间里的一个迭代器<code>recursive_directory_iterator</code><br>在遍历的时候还需要做两件事：I.剔除目录；II.根据扩展名，只保留html</li>
<li>提取标题<code>bool ParseTitle(const std::string&amp; html, std::string* title)</code>：使用<code>html.find(&quot;&lt;title&gt;&quot;)</code>查找<code>&lt;title&gt;</code>和<code>&lt;/title&gt;</code>标签，然后通过字符串取子串的方式<code>html.substr()</code>获取到标题内容</li>
<li>提取内容<code>bool ParseContent(const std::string&amp; html, std::string* content)</code>：除了标签之外的东西，都是正文<br>一个字符一个字符地提取，如果当前字符是正文内容，就写入结果。如果当前字符是&lt;认为标签开始，接下来的字符就舍弃；一直遇到&gt;认为标签结束，再恢复。遇到换行替换成空格。</li>
<li>提取url<code>bool ParseUrl(const std::string&amp; file_path, std::string* url)</code>：目标url为官网的网址+文档的路径<code>file_path</code>取子串</li>
</ul>
</li>
<li>分析文档结构：提取出文档的标题、正文、目标url<ul>
<li><code>struct DocInfo</code>：包含string类型的title、content、url</li>
<li>解析文件<code>bool ParserFile()</code><br>a.打开文件，读取文件内容<code>FileUtil::Read(file_path, &amp;html)</code>，在../common/util.hpp文件中定义<br>b.解析标题<code>ParseTitle(html, &amp;doc_info-&gt;title)</code>保存到结构体里<br>c.解析正文<code>ParseContent(html, &amp;doc_info-&gt;content)</code><br>d.解析url<code>ParseUrl(file_path, &amp;doc_info-&gt;url)</code></li>
<li>这里没有使用异常，仅仅写了报错日志</li>
</ul>
</li>
<li>合并文件：把所有的html文件的内容合并成一个行文本文件(raw_input)，每一行对应一个html文件，这样做的目的是为了后期索引模块处理时更方便<br><code>void WriteOutput(const DocInfo&amp; doc_info, std::ofstream&amp; file)</code>，把结构体里的内容，写到file文件里，这里要注意，在标题、url、正文中间都加了隐藏字符”\3”，最后再加一个换行</li>
</ul>
<p><strong>2.Makefile</strong><br>  <code>g++ parser.cc -o parser -std=c++11 -lboost_filesystem -lboost_system</code></p>
<h3 id="searcher模块"><a href="#searcher模块" class="headerlink" title="searcher模块"></a>searcher模块</h3><p><strong>1.searcher.h 构建索引模块和搜索模块(namespace searcher)</strong></p>
<ul>
<li>准备工作：<ul>
<li>Jieba分词：<code>#include &quot;../../cppjieba/include/cppjieba/Jieba.hpp&quot;</code></li>
<li><code>struct DocInfo</code>：里面包含doc_id、title、content、url</li>
<li><code>struct Weight</code>：包含doc_id、key(关键词)、weight(权重，采用词频计算权重，为后面排序做准备)</li>
<li>类型重命名：创建一个倒排拉链的类型<code>typedef std::vector&lt;Weight&gt; InvertedList</code></li>
</ul>
</li>
<li>索引模块<code>class Index</code><ul>
<li>知道某个词，获取对应的id列表：<code>std::unordered_map&lt;std::string, InvertedList&gt; inverted_index_;</code>，倒排索引使用unordered_map</li>
<li>知道id获取对应的文档内容，使用vector下标来表示文档id：<code>std::vector&lt;DocInfo&gt; forward_index_;</code>，正排索引使用vector</li>
<li>创建jieba对象：<code>cppjieba::Jieba jieba_;</code></li>
<li>读取raw_input文件，在内存中构建索引：<code>bool Build(const std::string&amp; input_path);</code></li>
<li>查正排，给定id找文档内容：<code>const DocInfo* GetDocInfo(uint64_t doc_id);</code></li>
<li>查倒排，给定词，找到这个词在哪些文档中出现过：<code>const InvertedList* GetInvertedList(const std::string&amp; key) const;</code></li>
<li>分词：<code>void CutWord(const std::string&amp; input, std::vector&lt;std::string&gt;* output);</code></li>
<li>构造函数：<code>Index();</code></li>
<li>构建正排：<code>const DocInfo* BuildForward(const std::string&amp; line);</code></li>
<li>构建倒排：<code>void BuildInverted(const DocInfo&amp; doc_info);</code></li>
</ul>
</li>
<li>搜索模块<code>class Searcher</code><ul>
<li>类类型：<code>Index* index_;</code></li>
<li>构造函数：<code>Searcher() : index_(new Index()) &#123;&#125; </code></li>
<li>析构函数：<code>~Searcher()&#123;delete index_;&#125;</code></li>
<li>加载索引：<code>bool Init(const std::string&amp; input_path);</code></li>
<li>通过特定的格式在result字符串中表示搜索结果：<code>bool Search(const std::string&amp; query, std::string* result);</code></li>
<li>通过关键词返回关于文档的描述：<code>std::string GetDesc(const std::string&amp; content, const std::string&amp; key);</code></li>
</ul>
</li>
</ul>
<p><strong>2.searcher.cc(namespace searcher)</strong></p>
<ul>
<li>使用json第三方库：<code>#include&lt;jsoncpp/json/json.h&gt;</code> </li>
<li>索引模块<ul>
<li>构造函数：<code>Index::Index() : jieba_(DICT_PATH, HMM_PATH, USER_DICT_PATH, IDF_PATH, STOP_WORD_PATH) &#123;&#125;</code>.分别代表所用到的jieba分词的文件路径</li>
<li>查正排：只要给定的doc_id数字小于正排索引的大小，就返回<code>&amp;forward_index_[doc_id]</code>，即DocInfo结构体里对应的doc_id</li>
<li>查倒排：找到位置<code>auto pos = inverted_index_.find(key);</code>，返回<code>&amp;pos-&gt;second;</code>，其类型为倒排拉链类型</li>
<li><strong>构造索引</strong>：a.构造DocInfo对象，更新正排索引数据，对读到的一行文件进行解析，得到DocInfo对象再插入vector中<code>const DocInfo* doc_info = BuildForward(line);</code>；b.更新倒排索引数据<code>BuildInverted(*doc_info);</code></li>
<li>构建正排：a.对一行内容进行切分(\3)，<code>StringUtil::Split(line, &amp;tokens, &quot;\3&quot;);</code>，借助boost里的split切分，把结果存放在vector类型的token里；b.构造一个DocInfo对象；c.把这个对象插入到正排索引中</li>
<li>构建倒排<ul>
<li>先对doc_info进行分词，对正文和标题分词<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; title_tokens;</span><br><span class="line"><span class="built_in">CutWord</span>(doc_info.title, &amp;title_tokens);</span><br><span class="line">std::vector&lt;std::string&gt; content_tokens;</span><br><span class="line"><span class="built_in">CutWord</span>(doc_info.content, &amp;content_tokens);</span><br></pre></td></tr></table></figure></li>
<li>对doc_info中的标题和正文进行词频统计，当前词在标题中出现几次，在正文中出现几次，<code>struct WordCnt&#123;int title_cnt; int content_cnt;&#125;</code><br>用一个hash表完成词频统计(统计是忽略大小写<code>boost::to_lower(word);</code>)<code>std::unordered_map&lt;std::string, WordCnt&gt; word_cnt;</code></li>
<li>遍历分词结果，在倒排索引中查找，如果该分词结果在倒排索引中不存在，就构建新的键值对；如果存在，找到对应的值(vector)，构建一个新的Weight对象插入到vector中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//word_pair的类型是std::pair，我们这里其实是把std::pair作为value用在了unordered_map中了</span></span><br><span class="line"><span class="comment">//因为unordered_map的key默认只能用基本类型，所以如果也需要用std::pair的话，</span></span><br><span class="line"><span class="comment">//就得提供hash函数(具体用法查看参考文献)，相应地map就不需要了 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word_pair : word_cnt) &#123;</span><br><span class="line">  Weight weight;</span><br><span class="line">  weight.doc_id = doc_info.doc_id; </span><br><span class="line">  weight.weight = <span class="number">10</span> * word_pair.second.title_cnt </span><br><span class="line">    + word_pair.second.content_cnt;</span><br><span class="line">  weight.key = word_pair.first;  <span class="comment">//把这个词顺便记录到Weight中</span></span><br><span class="line">  InvertedList&amp; inverted_index = inverted_index_[word_pair.first];</span><br><span class="line">  inverted_index.<span class="built_in">push_back</span>(weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>分词<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Index::CutWord</span><span class="params">(<span class="keyword">const</span> std::string&amp; input, </span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;std::string&gt;* output)</span></span>&#123; </span><br><span class="line">  jieba_.<span class="built_in">CutForSearch</span>(input, *output); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>搜索模块<ul>
<li>初始化加载索引：<code>return index_-&gt;Build(input_path);</code></li>
<li>query接收到的关键词搜索生成json格式的结果：<code>bool Searcher::Search(const std::string&amp; query, std::string* json_result)</code>   </li>
<li>[分词] 对查询词进行分词：<code>index_-&gt;CutWord(query, &amp;tokens);</code>，其中<code>std::vector&lt;std::string&gt; tokens;</code></li>
<li>[触发] 针对分词结果查倒排索引，找到哪些文档是具有相关性的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Weight&gt; all_token_result;</span><br><span class="line"><span class="keyword">for</span>(std::string word : tokens) &#123;</span><br><span class="line">  boost::<span class="built_in">to_lower</span>(word);</span><br><span class="line">  <span class="keyword">auto</span>* inverted_list = index_-&gt;<span class="built_in">GetInvertedList</span>(word);                                                                        </span><br><span class="line">  <span class="keyword">if</span>(inverted_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//不能因为某个分词的结果在索引中不存在就影响到其他的分词结果的查询</span></span><br><span class="line">    <span class="keyword">continue</span>;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//此处进一步的改进是考虑不同的分词结果对应相同文档id的情况，需要进行去重，</span></span><br><span class="line">  <span class="comment">//和权重合并，实现思路类似于合并有序链表</span></span><br><span class="line">  all_token_result.<span class="built_in">insert</span>(all_token_result.<span class="built_in">end</span>(),</span><br><span class="line">      inverted_list-&gt;<span class="built_in">begin</span>(), inverted_list-&gt;<span class="built_in">end</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[排序] 把这些结果按照一定规则排序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda表达式是一个匿名函数</span></span><br><span class="line">std::<span class="built_in">sort</span>(all_token_result.<span class="built_in">begin</span>(), all_token_result.<span class="built_in">end</span>(), </span><br><span class="line">    [](<span class="keyword">const</span> Weight&amp; w1, <span class="keyword">const</span> Weight&amp; w2)&#123;</span><br><span class="line">      <span class="keyword">return</span> w1.weight &gt; w2.weight;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
<li>[构造结果] 查正排，找到每个搜索结果的标题、正文、url<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预期构造成的结果：</span></span><br><span class="line"><span class="comment">//[</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//        &quot;title&quot;: &quot;标题&quot;,</span></span><br><span class="line"><span class="comment">//        &quot;desc&quot;: &quot;描述&quot;,</span></span><br><span class="line"><span class="comment">//        &quot;url&quot;:&quot;url&quot;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//]</span></span><br><span class="line">Json::Value results;   <span class="comment">//表示所有搜索结果的JSON对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; weight : all_token_result) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>* doc_info = index_-&gt;<span class="built_in">GetDocInfo</span>(weight.doc_id);</span><br><span class="line">  <span class="keyword">if</span>(doc_info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如何构造成 JSON结构，用第三方库来实现 jsoncpp</span></span><br><span class="line">  Json::Value result;   <span class="comment">//表示一条搜索结果的JSON对象</span></span><br><span class="line">  result[<span class="string">&quot;title&quot;</span>] = doc_info-&gt;title;</span><br><span class="line">  result[<span class="string">&quot;url&quot;</span>] = doc_info-&gt;url;</span><br><span class="line">  result[<span class="string">&quot;desc&quot;</span>] = <span class="built_in">GetDesc</span>(doc_info-&gt;content, weight.key);</span><br><span class="line">  results.<span class="built_in">append</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>借助jsoncpp能快速完成JSON对象和字符串的转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Json::FastWriter writer;</span><br><span class="line">*json_result = writer.<span class="built_in">write</span>(results);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>根据关键字返回关于文档的描述：描述是正文的一部分，描述最好要包含查询词<ul>
<li>现在正文中查找一下这个词的位置</li>
<li>以该位置为基准位置，往前截取60个字符，往后截取100个字符</li>
</ul>
</li>
</ul>
<p><strong>3.Makefile</strong><br>要生成动态库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FLAG=-std=c++<span class="number">11</span> -lboost_filesystem -lboost_system \</span><br><span class="line">                -I ../../cppjieba/include \</span><br><span class="line">                -ljsoncpp</span><br><span class="line"></span><br><span class="line">libsearcher.so:searcher.h searcher.cc </span><br><span class="line">        g++ searcher.cc -shared -fPIC -o libsearcher.so $(FLAG)</span><br></pre></td></tr></table></figure>

<h3 id="HttpServer模块"><a href="#HttpServer模块" class="headerlink" title="HttpServer模块"></a>HttpServer模块</h3><h2 id="1-http-server-cc"><a href="#1-http-server-cc" class="headerlink" title="1.http_server.cc"></a><strong>1.http_server.cc</strong></h2><p><strong>2.ProtocolUtil.hpp</strong><br>这部分详见<a target="_blank" rel="noopener" href="http://blog.fronna.com/Tech/Http-Server-1566191233.html">HttpServer</a></p>
<p><strong>3.Makefile</strong></p>
<h3 id="common模块"><a href="#common模块" class="headerlink" title="common模块"></a>common模块</h3><ul>
<li><code>class FileUtil</code><ul>
<li><code>static bool Read()</code>：ifstream，按行读取内容，保存到<code>string* content</code>里</li>
<li><code>static bool Write()</code>：ofstream，使用file.write()</li>
</ul>
</li>
<li><code>class StringUtil</code><ul>
<li><code>static void Spilt()</code>：基于boost的字符串切分实现<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/algorithm/string.hpp&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">const</span> std::string&amp; input, </span></span></span><br><span class="line"><span class="params"><span class="function">      std::vector&lt;std::string&gt;* output,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> std::string&amp; Split_char)</span> </span>&#123;</span><br><span class="line">    boost::<span class="built_in">split</span>(*output, input, boost::<span class="built_in">is_any_of</span>(Split_char),</span><br><span class="line">        boost::token_compress_off);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="问题与改进"><a href="#问题与改进" class="headerlink" title="问题与改进"></a>问题与改进</h2><h3 id="如果输入一个以上的词会得到raw-input里的所有东西"><a href="#如果输入一个以上的词会得到raw-input里的所有东西" class="headerlink" title="如果输入一个以上的词会得到raw_input里的所有东西"></a>如果输入一个以上的词会得到raw_input里的所有东西</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.techiedelight.com/use-std-pair-key-std-unordered_map-cpp/">How to use std::pair as key to std::unordered_map in C++</a></li>
</ul>
</blockquote>

            
                

            
        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="谢谢老板╰(*°▽°*)╯">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/tags/Proc/">Proc</a>
            
            <a href="/tags/SearchEngine/">SearchEngine</a>
            
        </div>
        
    </article>
    
        <p style="text-align: center">本文代表个人观点，内容仅供参考。若有不恰当之处，望不吝赐教！</p>
    
    
    
    


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/honjun/hexo-helper-tocbot/css/tocbot.css"><style>
    .js-toc {
        width: 200px;
        height: auto;
        z-index: 98;
        background-color: rgba(255,255,255,0);
        transform: translateX(0);
        right: 10%;
        top: 60px;
        position: fixed;
        padding-top: 10px;
        padding-bottom: 10px;
    }
  </style><script src="https://cdn.jsdelivr.net/gh/honjun/hexo-helper-tocbot/js/tocbot.js"></script><div class="js-toc"></div><script type="text/javascript">
    tocbot.init({"enable":true,"contentSelector":".post-content","scrollSmooth":true,"headingSelector":"h1, h2, h3, h4, h5","headingsOffset":45,"scrollSmoothOffset":-45,"tocSelector":".js-toc","ignoreSelector":".js-toc-ignore","linkClass":"toc-link","extraLinkClasses":"","activeLinkClass":"is-active-link","listClass":"toc-list","extraListClasses":"","isCollapsedClass":"is-collapsed","collapsibleClass":"is-collapsible","listItemClass":"toc-list-item","activeListItemClass":"is-active-li","collapseDepth":0,"scrollSmoothDuration":420,"throttleTimeout":50,"positionFixedSelector":null,"positionFixedClass":"is-position-fixed","fixedSidebarOffset":"auto","includeHtml":false,"onClick":false,"orderedList":true,"scrollContainer":null})
  </script>
</div>

<script src="/js/busuanzi.pure.mini.js"></script>




        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner" style="text-align: center">
<div>
    <p class="hitokoto"></p>
</div>
<script type="text/javascript" src="/js/hitokoto.js"></script>
        <p>
            <a href="/about"  title="关于">关于</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="帮助" >帮助</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="友链">友链</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/sitemap.xml" title="地图">地图</a>
        </p>
        <p>
            本站已建立&nbsp<a href="/timeline" id="siteBuildingTime"></a>&nbsp天，<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="licence">采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议创作</a><br/>
            ©2019-<span id="cpYear"></span> 基于&nbsp<a href="http://hexo.io" target="_blank" rel="nofollow">Hexo</a>
            ，主题采用&nbsp&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank" rel="bookmark">JSimple</a>
            ，作者&nbsp<a href="http://blog.fronna.com" target="_blank" rel="friend">方雷</a>
            ，Hosted by <a href="https://pages.github.com/" target="_blank" rel="nofollow">GitHub Pages</a>
        </p>
    </div>
</footer>

<script src="/js/SimpleCore.js"></script>




</div>
<!-- search pop -->
<div class="popup search-popup local-search-popup">
    <div class="local-search-header clearfix">
        <span class="search-icon">
            <i class="fa fa-search"></i>
        </span>
        <span class="popup-btn-close">
            <i class="fa fa-times-circle"></i>
        </span>
        <div class="local-search-input-wrapper">
            <input id="local-search-input"
                   spellcheck="false"
                   type="text"
                   autocomplete="off"
                   placeholder="请输入查询关键词"/>
        </div>
    </div>
    <div id="local-search-result"></div>
</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<!--
<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
-->
<script>
    $(function () {
        var jsi_config = {
            buildingTime: '08/01/2019',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
            localSearch: { dbPath: '' },
            readMode: 'day'
        };
        
        SimpleCore.init(jsi_config);
        
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
        
    });
</script>
</body>
</html>
